Package sc;

Helpers
    lettre = [['a' .. 'z'] + ['A' .. 'Z']];
    chiffre = ['0' .. '9'];
    alpha = [lettre + ['_' + '$']];
    alphanum = [lettre + chiffre];

Tokens
    crochet_gauche = '[';
    crochet_droit = ']';
    parenthese_gauche = '(';
    parenthese_droite = ')';
    accolade_gauche = '{';
    accolade_droite = '}';

    si = 'si';
    sinon = 'sinon';
    alors = 'alors';
    tant_que = 'tantque';
    faire = 'faire';
    ecrire = 'ecrire';
    retour = 'retour';
    lire = 'lire';

    ou = '|';
    et = '&';
    egal = '=';
    inf = '<';
    plus = '+';
    moins = '-';
    mult = '*';
    div = '/';
    exclamation = '!';

    bool = 'bool';
    entier = 'entier';
    vrai = 'vrai';
    faux = 'faux';
    virgule = ',';
    point_virgule = ';';

    espace = (' ' | 13 | 10)+;
    commentaire = '#' [[0 .. 0xffff] - [10 + 13]]* (10 | 13 | 10 13);
    nombre = chiffre+;
    identif = alpha alphanum*;

Ignored Tokens
    espace, commentaire;

Productions
    programme =
        {axiome} liste_var liste_fonc;

    liste_var =
        declaration_var liste_var_prime |
        {vide} ;

    liste_var_prime =
        virgule declaration_var liste_var_prime |
        {vide} ;

    declaration_var =
        type identif |
        {tableau} type identif crochet_gauche nombre crochet_droit;


    liste_fonc =
        declaration_fonc liste_fonc |
        {vide} ;

    declaration_fonc =
        type_optionnel identif parenthese_gauche [argument]:liste_var parenthese_droite [var_locale]:liste_var bloc_instruction;

    type =
        {bool} bool |
        {entier} entier;

    type_optionnel =
        {type} type |
        {vide} ;


    bloc_instruction =
        accolade_gauche liste_instruction accolade_droite;

    liste_instruction =
        instruction liste_instruction |
        {vide} ;

    instruction =
        {affectation} var egal expr point_virgule |
        {si} si expr alors bloc_instruction |
        {si_sinon} si expr alors [si_instruction]:bloc_instruction sinon [sinon_instruction]:bloc_instruction |
        {tant_que} tant_que expr faire bloc_instruction |
        {retour} retour expr point_virgule |
        {appel_fonction} identif parenthese_gauche liste_expr parenthese_droite point_virgule |
        {ecrire} ecrire parenthese_gauche expr parenthese_droite point_virgule;


    var =
        identif |
        {tableau} identif crochet_gauche expr crochet_droit;

    liste_expr =
        expr liste_expr_prime |
        {vide} ;

    liste_expr_prime =
        virgule expr liste_expr_prime |
        {vide} ;

    expr =
        {ou} expr ou expr2 |
        {priorite_suivante} expr2;

    expr2 =
        {et} expr2 et expr3 |
        {priorite_suivante} expr3;

    expr3 =
        {egal} expr3 egal expr4 |
        {inf} expr3 inf expr4 |
        {priorite_suivante} expr4;

    expr4 =
        {plus} expr4 plus expr5 |
        {moins} expr4 moins expr5 |
        {priorite_suivante} expr5;

    expr5 =
        {mult} expr5 mult expr6 |
        {div} expr5 div expr6 |
        {priorite_suivante} expr6;

    expr6 =
        {non} exclamation expr6 |
        {priorite_suivante} expr7;

    expr7 =
        {entre_parantheses} parenthese_gauche expr parenthese_droite |
        {nombre} nombre |
        {vrai} vrai |
        {faux} faux |
        {appel_fonction} identif parenthese_gauche liste_expr parenthese_droite |
        {lire} lire parenthese_gauche parenthese_droite |
        {variable} var;